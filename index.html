<script src="C:\Users\jonas.kongshaug\Downloads\three.js-master\build\three.js"> </script>
<script src="C:\Users\jonas.kongshaug\Downloads\three.js-master\examples\js\controls\OrbitControls.js"> </script>

<div></div>
<script>

    let renderer, scene, camera, canvas, controls;
    init();
    function init(){
        renderer = new THREE.WebGLRenderer({depth: true, logarithmicDepthBuffer: true});
        
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        canvas = renderer.domElement;


        let aspect = window.innerWidth / window.innerHeight, size = 5;
        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
        //camera = new THREE.OrthographicCamera(-size * aspect, size * aspect, size, -size, 1, 500 );
        camera.position.z = 4;


        controls = new THREE.OrbitControls( camera, renderer.domElement );
        //controls.enableDamping = true;
        
        
        target = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
        //target.texture.minFilter = THREE.NearestFilter;
        //target.texture.magFilter = THREE.NearestFilter;
        target.stencilBuffer = true;
        target.depthTexture = new THREE.DepthTexture();
        //target.depthTexture.format = THREE.DepthStencilFormat;
        //target.depthTexture.type = THREE.UnsignedShortType;
        
        
        scene = new THREE.Scene();
        let box1 = new THREE.BoxGeometry(1,1,1);
        let box2 = new THREE.BoxGeometry(1,1,1);
        box2.translate(2,1,0);

        let newIndex = [...box1.index.array];
        let increase = box1.attributes.position.count;
        for (i = 0; i < box2.index.array.length; i++){
            newIndex.push(box2.index.array[i] + increase);
        }
        let mergedBoxes = new THREE.BufferGeometry();
        mergedBoxes.setAttribute("position", new THREE.Float32BufferAttribute([...box1.attributes.position.array, ...box2.attributes.position.array], 3));
        mergedBoxes.setIndex(newIndex);
        window.mergedBoxes = mergedBoxes;
        let edgeGeo = new THREE.EdgesGeometry(mergedBoxes);
        let lineMesh = new THREE.LineSegments(edgeGeo, new THREE.MeshBasicMaterial({color:Math.floor(0xFFFFFF * Math.random())}));
        scene.add(lineMesh);
        //addMesh(mergedBoxes)
        //addMesh(new THREE.TorusKnotGeometry(1,.35,88,8,2,3))
        
        //sadus = new THREE.Mesh(new THREE.TorusKnotGeometry(1,.35,88,8,2,3),coolM());// new THREE.MeshBasicMaterial({color:Math.floor(0xFFFFFF * Math.random())}));
        //scene.add(new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial ({map: target.depthTexture})));
        
        let light = new THREE.PointLight( 0xffffff, 1, 10000 );
        light.position.set( 50, 50, 50 );
        scene.add( light );
        scene.add(new THREE.AmbientLight(0xffffff, .5))
    }
    
    let _stop;
    let update = ()=> {
        if (_stop) return;
        //renderer.setRenderTarget(target)
        //renderer.render(sadus, camera);
        renderer.setRenderTarget(null)
        renderer.render(scene, camera);
        
        
        requestAnimationFrame(update);
    }
    update();
    function bimbom(){
        _stop = !_stop;
        if (!_stop) {
            update();
            return "Stortdd🏁"
        }
        return "Stoptds🛑"
    }


    function coolM(){
        return new THREE.ShaderMaterial({
            vertexShader:`
                varying vec2 vUv;
                varying vec4 vPo;

                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    vPo = gl_Position;
                }
            `,
            fragmentShader:`
                    precision highp float;
                    uniform float u_time;
                    varying vec2 vUv;
                    varying vec4 vPo;

                    vec3 vary(vec3 y)
                    {
                        y = y+sin(u_time*1.5)*y.r;
                        return y;
                    }

                    void main(){
                        vec2 st = vUv;
                        vec3 color = vary(vec3(gl_PointCoord.x, gl_PointCoord.y, 1 ) );
                        gl_FragColor = vec4(gl_FragDepth * 10000000.0 ,.1,.1, 1 );
                    }
            `,
            uniforms: {
						cameraNear: { value: camera.near },
						cameraFar: { value: camera.far },
						//tDiffuse: { value: null },
						tDepth: { value: target.depthTexture }
					}

        });
        // float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
        // float viewZ = -perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );
        // float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
        // gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);
    }

    function outlineMesh(meshArr, scene, distance){
        let mGeo = mesh.geometry;
        mGeo.computeVertexNormals();
        let oGeo = mGeo.clone();
        for (let i = 0; i < oGeo.attributes.position.count * 3; i++){
            let remem = oGeo.attributes.position.array[i];
            oGeo.attributes.position.array[i] += oGeo.attributes.normal.array[i] * distance;
            //oGeo.attributes.normal.array[i] = -oGeo.attributes.normal.array[i]
        }
        oGeo.attributes.position.needsUpdate = true;
        //oGeo.attributes.position.needsUpdate = true;
        let oMesh = new THREE.Mesh(oGeo, new THREE.MeshBasicMaterial({color: 0x888888, side: THREE.BackSide}))
        scene.add(oMesh)
    }


    function addMesh(geo){
        geo.attributes.position.needsUpdate = true;
        let mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:Math.floor(0xFFFFFF * Math.random())})); //  new THREE.MeshDepthMaterial())// coolM());// 
        scene.add(mesh);
        return mesh;
    }
</script>
